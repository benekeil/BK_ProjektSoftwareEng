{"ast":null,"code":"import { __rest } from 'tslib';\nimport React from 'react';\nimport { matchPath, withRouter, BrowserRouter, HashRouter } from 'react-router-dom';\nimport { NavContext, IonLifeCycleContext, DefaultIonLifeCycleContext, getConfig } from '@ionic/react';\nlet count = 0;\n\nconst generateId = () => (count++).toString();\n\nconst isDevMode = () => {\n  return process && process.env && process.env.NODE_ENV === 'development';\n};\n\nconst RESTRICT_SIZE = 25;\n\nclass LocationHistory {\n  constructor() {\n    this.locationHistory = [];\n  }\n\n  add(location) {\n    this.locationHistory.push(location);\n\n    if (this.locationHistory.length > RESTRICT_SIZE) {\n      this.locationHistory.splice(0, 10);\n    }\n  }\n\n  pop() {\n    this.locationHistory.pop();\n  }\n\n  replace(location) {\n    this.locationHistory.pop();\n    this.locationHistory.push(location);\n  }\n\n  clear() {\n    this.locationHistory = [];\n  }\n\n  findLastLocationByUrl(url) {\n    for (let i = this.locationHistory.length - 1; i >= 0; i--) {\n      const location = this.locationHistory[i];\n\n      if (location.pathname.toLocaleLowerCase() === url.toLocaleLowerCase()) {\n        return location;\n      }\n    }\n\n    return undefined;\n  }\n\n  previous() {\n    return this.locationHistory[this.locationHistory.length - 2];\n  }\n\n  current() {\n    return this.locationHistory[this.locationHistory.length - 1];\n  }\n\n}\n/**\n * The holistic view of all the Routes configured for an application inside of an IonRouterOutlet.\n */\n\n\nclass ViewStacks {\n  constructor() {\n    this.viewStacks = {};\n  }\n\n  get(key) {\n    return this.viewStacks[key];\n  }\n\n  set(key, viewStack) {\n    this.viewStacks[key] = viewStack;\n  }\n\n  getKeys() {\n    return Object.keys(this.viewStacks);\n  }\n\n  delete(key) {\n    delete this.viewStacks[key];\n  }\n\n  findViewInfoByLocation(location, viewKey) {\n    let view;\n    let match;\n    let viewStack;\n\n    if (viewKey) {\n      viewStack = this.viewStacks[viewKey];\n\n      if (viewStack) {\n        viewStack.views.some(matchView);\n      }\n    } else {\n      const keys = this.getKeys();\n      keys.some(key => {\n        viewStack = this.viewStacks[key];\n        return viewStack.views.some(matchView);\n      });\n    }\n\n    const result = {\n      view,\n      viewStack,\n      match\n    };\n    return result;\n\n    function matchView(v) {\n      const matchProps = {\n        exact: v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component\n      };\n      const myMatch = matchPath(location.pathname, matchProps);\n\n      if (myMatch) {\n        view = v;\n        match = myMatch;\n        return view.location === location.pathname;\n      }\n\n      return false;\n    }\n  }\n\n  findViewInfoById(id = '') {\n    let view;\n    let viewStack;\n    const keys = this.getKeys();\n    keys.some(key => {\n      const vs = this.viewStacks[key];\n      view = vs.views.find(x => x.id === id);\n\n      if (view) {\n        viewStack = vs;\n        return true;\n      } else {\n        return false;\n      }\n    });\n    return {\n      view,\n      viewStack\n    };\n  }\n\n}\n\nconst RouteManagerContext =\n/*@__PURE__*/\nReact.createContext({\n  viewStacks: new ViewStacks(),\n  syncView: () => {\n    navContextNotFoundError();\n  },\n  syncRoute: () => {\n    navContextNotFoundError();\n  },\n  hideView: () => {\n    navContextNotFoundError();\n  },\n  setupIonRouter: () => Promise.reject(navContextNotFoundError()),\n  removeViewStack: () => {\n    navContextNotFoundError();\n  },\n  getRoute: () => {\n    navContextNotFoundError();\n  }\n});\n\nfunction navContextNotFoundError() {\n  console.error('IonReactRouter not found, did you add it to the app?');\n}\n/**\n * The View component helps manage the IonPage's lifecycle and registration\n */\n\n\nclass View extends React.Component {\n  componentWillUnmount() {\n    if (this.ionPage) {\n      this.ionPage.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n      this.ionPage.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n      this.ionPage.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n      this.ionPage.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n    }\n  }\n\n  ionViewWillEnterHandler() {\n    this.context.ionViewWillEnter();\n  }\n\n  ionViewDidEnterHandler() {\n    this.context.ionViewDidEnter();\n  }\n\n  ionViewWillLeaveHandler() {\n    this.context.ionViewWillLeave();\n  }\n\n  ionViewDidLeaveHandler() {\n    this.context.ionViewDidLeave();\n  }\n\n  registerIonPage(page) {\n    this.ionPage = page;\n    this.ionPage.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n    this.ionPage.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n    this.ionPage.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n    this.ionPage.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n    this.ionPage.classList.add('ion-page-invisible');\n\n    if (isDevMode()) {\n      this.ionPage.setAttribute('data-view-id', this.props.view.id);\n    }\n\n    this.props.onViewSync(page, this.props.view.id);\n  }\n\n  render() {\n    return React.createElement(NavContext.Consumer, null, value => {\n      const newProvider = Object.assign(Object.assign({}, value), {\n        registerIonPage: this.registerIonPage.bind(this)\n      });\n      return React.createElement(NavContext.Provider, {\n        value: newProvider\n      }, this.props.children);\n    });\n  }\n\n  static get contextType() {\n    return IonLifeCycleContext;\n  }\n\n}\n/**\n * Manages the View's DOM lifetime by keeping it around long enough to complete page transitions before removing it.\n */\n\n\nclass ViewTransitionManager extends React.Component {\n  constructor(props) {\n    super(props);\n    this.ionLifeCycleContext = new DefaultIonLifeCycleContext();\n    this._isMounted = false;\n    this.state = {\n      show: true\n    };\n    this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {\n      if (!this.props.mount) {\n        if (this._isMounted) {\n          this.setState({\n            show: false\n          }, () => {\n            this.context.hideView(this.props.id);\n          });\n        }\n      }\n    });\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  render() {\n    const show = this.state.show;\n    return React.createElement(IonLifeCycleContext.Provider, {\n      value: this.ionLifeCycleContext\n    }, show && this.props.children);\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n\n}\n\nclass StackManagerInner extends React.Component {\n  constructor(props) {\n    super(props);\n    this.routerOutletEl = React.createRef();\n    this.id = this.props.id || generateId();\n    this.handleViewSync = this.handleViewSync.bind(this);\n    this.handleHideView = this.handleHideView.bind(this);\n    this.state = {};\n  }\n\n  componentDidMount() {\n    this.props.routeManager.setupIonRouter(this.id, this.props.children, this.routerOutletEl.current);\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    props.routeManager.syncRoute('', props.children);\n    return state;\n  }\n\n  componentWillUnmount() {\n    this.props.routeManager.removeViewStack(this.id);\n  }\n\n  handleViewSync(page, viewId) {\n    this.props.routeManager.syncView(page, viewId);\n  }\n\n  handleHideView(viewId) {\n    this.props.routeManager.hideView(viewId);\n  }\n\n  renderChild(item, route) {\n    const component = React.cloneElement(route, {\n      computedMatch: item.routeData.match\n    });\n    return component;\n  }\n\n  render() {\n    const routeManager = this.props.routeManager;\n    const viewStack = routeManager.viewStacks.get(this.id);\n    const views = (viewStack || {\n      views: []\n    }).views.filter(x => x.show);\n    const ionRouterOutlet = React.Children.only(this.props.children);\n    const childElements = views.map(view => {\n      const route = routeManager.getRoute(view.routeId);\n      return React.createElement(ViewTransitionManager, {\n        id: view.id,\n        key: view.key,\n        mount: view.mount\n      }, React.createElement(View, {\n        onViewSync: this.handleViewSync,\n        onHideView: this.handleHideView,\n        view: view,\n        route: route\n      }, this.renderChild(view, route)));\n    });\n    const elementProps = {\n      ref: this.routerOutletEl\n    };\n\n    if (ionRouterOutlet.props.forwardedRef) {\n      ionRouterOutlet.props.forwardedRef.current = this.routerOutletEl;\n    }\n\n    if (isDevMode()) {\n      elementProps['data-stack-id'] = this.id;\n    }\n\n    const routerOutletChild = React.cloneElement(ionRouterOutlet, elementProps, childElements);\n    return routerOutletChild;\n  }\n\n}\n\nconst withContext = Component => {\n  return props => React.createElement(RouteManagerContext.Consumer, null, context => React.createElement(Component, Object.assign({}, props, {\n    routeManager: context\n  })));\n};\n\nconst StackManager = withContext(StackManagerInner);\n\nclass NavManager extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      goBack: this.goBack.bind(this),\n      hasIonicRouter: () => true,\n      navigate: this.navigate.bind(this),\n      getStackManager: this.getStackManager.bind(this),\n      getPageManager: this.getPageManager.bind(this),\n      currentPath: this.props.location.pathname,\n      registerIonPage: () => {\n        return;\n      } // overridden in View for each IonPage\n\n    };\n    this.listenUnregisterCallback = this.props.history.listen(location => {\n      this.setState({\n        currentPath: location.pathname\n      });\n    });\n\n    if (document) {\n      document.addEventListener('ionBackButton', e => {\n        e.detail.register(0, () => {\n          this.props.history.goBack();\n        });\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.listenUnregisterCallback) {\n      this.listenUnregisterCallback();\n    }\n  }\n\n  goBack(defaultHref) {\n    this.props.onNavigateBack(defaultHref);\n  }\n\n  navigate(path, direction, ionRouteAction = 'push') {\n    this.props.onNavigate(ionRouteAction, path, direction);\n  }\n\n  getPageManager() {\n    return children => children;\n  }\n\n  getStackManager() {\n    return StackManager;\n  }\n\n  render() {\n    return React.createElement(NavContext.Provider, {\n      value: this.state\n    }, this.props.children);\n  }\n\n}\n\nclass RouteManager extends React.Component {\n  constructor(props) {\n    super(props);\n    this.locationHistory = new LocationHistory();\n    this.routes = {};\n    this.ionPageElements = {};\n    this.routerOutlets = {};\n    this.firstRender = true;\n    this.listenUnregisterCallback = this.props.history.listen(this.historyChange.bind(this));\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.navigateBack = this.navigateBack.bind(this);\n    this.state = {\n      viewStacks: new ViewStacks(),\n      hideView: this.hideView.bind(this),\n      setupIonRouter: this.setupIonRouter.bind(this),\n      removeViewStack: this.removeViewStack.bind(this),\n      syncView: this.syncView.bind(this),\n      syncRoute: this.syncRoute.bind(this),\n      getRoute: this.getRoute.bind(this)\n    };\n    this.locationHistory.add({\n      hash: window.location.hash,\n      key: generateId(),\n      pathname: window.location.pathname,\n      search: window.location.search,\n      state: {}\n    });\n  }\n\n  componentDidUpdate(_prevProps, prevState) {\n    // Trigger a page change if the location or action is different\n    if (this.state.location && prevState.location !== this.state.location || prevState.action !== this.state.action) {\n      const viewStacks = Object.assign(new ViewStacks(), this.state.viewStacks);\n      this.setActiveView(this.state.location, this.state.action, viewStacks);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.listenUnregisterCallback) {\n      this.listenUnregisterCallback();\n    }\n  }\n\n  getRoute(id) {\n    return this.routes[id];\n  }\n\n  hideView(viewId) {\n    const viewStacks = Object.assign(new ViewStacks(), this.state.viewStacks);\n\n    const _viewStacks$findViewI = viewStacks.findViewInfoById(viewId),\n          view = _viewStacks$findViewI.view;\n\n    if (view) {\n      view.show = false;\n      view.isIonRoute = false;\n      view.prevId = undefined;\n      view.key = generateId();\n      delete this.ionPageElements[view.id];\n      this.setState({\n        viewStacks\n      });\n    }\n  }\n\n  historyChange(location, action) {\n    const ionRouteAction = this.currentIonRouteAction === 'pop' ? 'pop' : action.toLowerCase();\n    let direction = this.currentRouteDirection;\n\n    if (ionRouteAction === 'push') {\n      this.locationHistory.add(location);\n    } else if (ionRouteAction === 'pop') {\n      this.locationHistory.pop();\n      direction = direction || 'back';\n    } else if (ionRouteAction === 'replace') {\n      this.locationHistory.replace(location);\n      direction = 'none';\n    }\n\n    if (direction === 'root') {\n      this.locationHistory.clear();\n      this.locationHistory.add(location);\n    }\n\n    location.state = location.state || {\n      direction\n    };\n    this.setState({\n      location,\n      action: ionRouteAction\n    });\n    this.currentRouteDirection = undefined;\n    this.currentIonRouteAction = undefined;\n  }\n\n  setActiveView(location, action, viewStacks) {\n    let direction = location.state && location.state.direction || 'forward';\n    let leavingView;\n    const viewStackKeys = viewStacks.getKeys();\n    let shouldTransitionPage = false;\n    let leavingViewHtml;\n    viewStackKeys.forEach(key => {\n      const _viewStacks$findViewI2 = viewStacks.findViewInfoByLocation(location, key),\n            enteringView = _viewStacks$findViewI2.view,\n            enteringViewStack = _viewStacks$findViewI2.viewStack,\n            match = _viewStacks$findViewI2.match;\n\n      if (!enteringView || !enteringViewStack) {\n        return;\n      }\n\n      leavingView = viewStacks.findViewInfoById(this.activeIonPageId).view;\n\n      if (enteringView.isIonRoute) {\n        enteringView.show = true;\n        enteringView.mount = true;\n        enteringView.routeData.match = match;\n        shouldTransitionPage = true;\n        this.activeIonPageId = enteringView.id;\n\n        if (leavingView) {\n          if (action === 'push' && direction === 'forward') {\n            /**\n             * If the page is being pushed into the stack by another view,\n             * record the view that originally directed to the new view for back button purposes.\n             */\n            enteringView.prevId = leavingView.id;\n          } else if (action === 'pop' || action === 'replace') {\n            leavingView.mount = false;\n            this.removeOrphanedViews(enteringView, enteringViewStack);\n          }\n\n          leavingViewHtml = enteringView.id === leavingView.id ? this.ionPageElements[leavingView.id].outerHTML : undefined;\n        } else {\n          // If there is not a leavingView, then we shouldn't provide a direction\n          direction = undefined;\n        }\n      } else {\n        enteringView.show = true;\n        enteringView.mount = true;\n        enteringView.routeData.match = match;\n      }\n    });\n\n    if (leavingView) {\n      if (!leavingView.isIonRoute) {\n        leavingView.mount = false;\n        leavingView.show = false;\n      }\n    }\n\n    this.setState({\n      viewStacks\n    }, () => {\n      if (shouldTransitionPage) {\n        const _this$state$viewStack = this.state.viewStacks.findViewInfoById(this.activeIonPageId),\n              enteringView = _this$state$viewStack.view,\n              viewStack = _this$state$viewStack.viewStack;\n\n        if (enteringView && viewStack) {\n          const enteringEl = this.ionPageElements[enteringView.id];\n          const leavingEl = leavingView && this.ionPageElements[leavingView.id];\n\n          if (enteringEl) {\n            let navDirection;\n\n            if (leavingEl && leavingEl.innerHTML === '') {\n              // Don't animate from an empty view\n              navDirection = undefined;\n            } else if (direction === 'none' || direction === 'root') {\n              navDirection = undefined;\n            } else {\n              navDirection = direction;\n            }\n\n            const shouldGoBack = !!enteringView.prevId;\n            const routerOutlet = this.routerOutlets[viewStack.id];\n            this.commitView(enteringEl, leavingEl, routerOutlet, navDirection, shouldGoBack, leavingViewHtml);\n          } else if (leavingEl) {\n            leavingEl.classList.add('ion-page-hidden');\n            leavingEl.setAttribute('aria-hidden', 'true');\n          }\n        } // Warn if an IonPage was not eventually rendered in Dev Mode\n\n\n        if (isDevMode()) {\n          if (enteringView && enteringView.routeData.match.url !== location.pathname) {\n            setTimeout(() => {\n              const _this$state$viewStack2 = this.state.viewStacks.findViewInfoById(this.activeIonPageId),\n                    view = _this$state$viewStack2.view;\n\n              if (view.routeData.match.url !== location.pathname) {\n                console.warn('No IonPage was found to render. Make sure you wrap your page with an IonPage component.');\n              }\n            }, 100);\n          }\n        }\n      }\n    });\n  }\n\n  removeOrphanedViews(view, viewStack) {\n    // Note: This technique is a bit wonky for views that reference each other and get into a circular loop.\n    // It can still remove a view that probably shouldn't be.\n    const viewsToRemove = viewStack.views.filter(v => v.prevId === view.id);\n    viewsToRemove.forEach(v => {\n      // Don't remove if view is currently active\n      if (v.id !== this.activeIonPageId) {\n        this.removeOrphanedViews(v, viewStack); // If view is not currently visible, go ahead and remove it from DOM\n\n        const page = this.ionPageElements[v.id];\n\n        if (page.classList.contains('ion-page-hidden')) {\n          v.show = false;\n          v.isIonRoute = false;\n          v.prevId = undefined;\n          v.key = generateId();\n          delete this.ionPageElements[v.id];\n        }\n\n        v.mount = false;\n      }\n    });\n  }\n\n  setupIonRouter(id, children, routerOutlet) {\n    const views = [];\n    let activeId;\n    const ionRouterOutlet = React.Children.only(children);\n    React.Children.forEach(ionRouterOutlet.props.children, child => {\n      const routeId = generateId();\n      this.routes[routeId] = child;\n      views.push(createViewItem(child, routeId, this.props.history.location));\n    });\n    this.registerViewStack(id, activeId, views, routerOutlet, this.props.location);\n\n    function createViewItem(child, routeId, location) {\n      const viewId = generateId();\n      const key = generateId(); // const route = child;\n\n      const matchProps = {\n        exact: child.props.exact,\n        path: child.props.path || child.props.from,\n        component: child.props.component\n      };\n      const match = matchPath(location.pathname, matchProps);\n      const view = {\n        id: viewId,\n        key,\n        routeData: {\n          match,\n          childProps: child.props\n        },\n        routeId,\n        mount: true,\n        show: !!match,\n        isIonRoute: false\n      };\n\n      if (match && view.isIonRoute) {\n        activeId = viewId;\n      }\n\n      return view;\n    }\n  }\n\n  registerViewStack(stack, activeId, stackItems, routerOutlet, _location) {\n    this.setState(prevState => {\n      const prevViewStacks = Object.assign(new ViewStacks(), prevState.viewStacks);\n      const newStack = {\n        id: stack,\n        views: stackItems\n      };\n      this.routerOutlets[stack] = routerOutlet;\n\n      if (activeId) {\n        this.activeIonPageId = activeId;\n      }\n\n      prevViewStacks.set(stack, newStack);\n      return {\n        viewStacks: prevViewStacks\n      };\n    }, () => {\n      this.setupRouterOutlet(routerOutlet);\n    });\n  }\n\n  async setupRouterOutlet(routerOutlet) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n\n      if (swipeEnabled) {\n        const _this$state$viewStack3 = this.state.viewStacks.findViewInfoById(this.activeIonPageId),\n              view = _this$state$viewStack3.view;\n\n        return !!(view && view.prevId);\n      } else {\n        return false;\n      }\n    };\n\n    const onStart = () => {\n      this.navigateBack();\n    };\n\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd: _shouldContinue => true\n    };\n  }\n\n  removeViewStack(stack) {\n    const viewStacks = Object.assign(new ViewStacks(), this.state.viewStacks);\n    viewStacks.delete(stack);\n    this.setState({\n      viewStacks\n    });\n  }\n\n  syncView(page, viewId) {\n    const viewStacks = Object.assign(new ViewStacks(), this.state.viewStacks);\n\n    const _viewStacks$findViewI3 = viewStacks.findViewInfoById(viewId),\n          view = _viewStacks$findViewI3.view;\n\n    if (view) {\n      view.isIonRoute = true;\n      this.ionPageElements[view.id] = page;\n      this.setActiveView(this.state.location || this.props.location, this.state.action, viewStacks);\n    }\n  }\n\n  syncRoute(_id, routerOutlet) {\n    const ionRouterOutlet = React.Children.only(routerOutlet);\n    React.Children.forEach(ionRouterOutlet.props.children, child => {\n      for (const routeKey in this.routes) {\n        const route = this.routes[routeKey];\n\n        if (route.props.path === child.props.path) {\n          this.routes[routeKey] = child;\n        }\n      }\n    });\n  }\n\n  async commitView(enteringEl, leavingEl, ionRouterOutlet, direction, showGoBack, leavingViewHtml) {\n    if (!this.firstRender) {\n      if (!('componentOnReady' in ionRouterOutlet)) {\n        await waitUntilRouterOutletReady(ionRouterOutlet);\n      }\n\n      if (enteringEl === leavingEl && direction && leavingViewHtml) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n        const newLeavingElement = clonePageElement(leavingViewHtml);\n        ionRouterOutlet.appendChild(newLeavingElement);\n        await ionRouterOutlet.commit(enteringEl, newLeavingElement, {\n          deepWait: true,\n          duration: direction === undefined ? 0 : undefined,\n          direction,\n          showGoBack,\n          progressAnimation: false\n        });\n        ionRouterOutlet.removeChild(newLeavingElement);\n      } else {\n        await ionRouterOutlet.commit(enteringEl, leavingEl, {\n          deepWait: true,\n          duration: direction === undefined ? 0 : undefined,\n          direction,\n          showGoBack,\n          progressAnimation: false\n        });\n      }\n\n      if (leavingEl && enteringEl !== leavingEl) {\n        /** add hidden attributes */\n        leavingEl.classList.add('ion-page-hidden');\n        leavingEl.setAttribute('aria-hidden', 'true');\n      }\n    } else {\n      enteringEl.classList.remove('ion-page-invisible');\n      enteringEl.style.zIndex = '101';\n      enteringEl.dispatchEvent(new Event('ionViewWillEnter'));\n      enteringEl.dispatchEvent(new Event('ionViewDidEnter'));\n      this.firstRender = false;\n    }\n  }\n\n  handleNavigate(ionRouteAction, path, direction) {\n    this.currentIonRouteAction = ionRouteAction;\n\n    switch (ionRouteAction) {\n      case 'push':\n        this.currentRouteDirection = direction;\n        this.props.history.push(path);\n        break;\n\n      case 'pop':\n        this.currentRouteDirection = direction || 'back';\n        this.props.history.replace(path);\n        break;\n\n      case 'replace':\n        this.currentRouteDirection = 'none';\n        this.props.history.replace(path);\n        break;\n    }\n  }\n\n  navigateBack(defaultHref) {\n    const _this$state$viewStack4 = this.state.viewStacks.findViewInfoById(this.activeIonPageId),\n          leavingView = _this$state$viewStack4.view;\n\n    if (leavingView) {\n      if (leavingView.id === leavingView.prevId) {\n        const previousLocation = this.locationHistory.previous();\n\n        if (previousLocation) {\n          this.handleNavigate('pop', previousLocation.pathname + previousLocation.search);\n        } else {\n          defaultHref && this.handleNavigate('pop', defaultHref);\n        }\n      } else {\n        const _this$state$viewStack5 = this.state.viewStacks.findViewInfoById(leavingView.prevId),\n              enteringView = _this$state$viewStack5.view;\n\n        if (enteringView) {\n          const lastLocation = this.locationHistory.findLastLocationByUrl(enteringView.routeData.match.url);\n\n          if (lastLocation) {\n            this.handleNavigate('pop', lastLocation.pathname + lastLocation.search);\n          } else {\n            this.handleNavigate('pop', enteringView.routeData.match.url);\n          }\n        } else {\n          const currentLocation = this.locationHistory.previous();\n\n          if (currentLocation) {\n            this.handleNavigate('pop', currentLocation.pathname + currentLocation.search);\n          } else {\n            if (defaultHref) {\n              this.handleNavigate('pop', defaultHref);\n            }\n          }\n        }\n      }\n    } else {\n      if (defaultHref) {\n        this.handleNavigate('replace', defaultHref, 'back');\n      }\n    }\n  }\n\n  render() {\n    return React.createElement(RouteManagerContext.Provider, {\n      value: this.state\n    }, React.createElement(NavManager, Object.assign({}, this.props, {\n      onNavigateBack: this.navigateBack,\n      onNavigate: this.handleNavigate\n    }), this.props.children));\n  }\n\n}\n\nfunction clonePageElement(leavingViewHtml) {\n  const newEl = document.createElement('div');\n  newEl.innerHTML = leavingViewHtml;\n  newEl.classList.add('ion-page-hidden');\n  newEl.style.zIndex = ''; // Remove an existing back button so the new element doesn't get two of them\n\n  const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n\n  if (ionBackButton[0]) {\n    ionBackButton[0].innerHTML = '';\n  }\n\n  return newEl.firstChild;\n}\n\nasync function waitUntilRouterOutletReady(ionRouterOutlet) {\n  if ('componentOnReady' in ionRouterOutlet) {\n    return;\n  } else {\n    setTimeout(() => {\n      waitUntilRouterOutletReady(ionRouterOutlet);\n    }, 0);\n  }\n}\n\nconst RouteManagerWithRouter = withRouter(RouteManager);\nRouteManagerWithRouter.displayName = 'RouteManager';\n\nclass IonReactRouter extends React.Component {\n  render() {\n    const _a = this.props,\n          children = _a.children,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(BrowserRouter, Object.assign({}, props), React.createElement(RouteManagerWithRouter, null, children));\n  }\n\n}\n\nclass IonReactHashRouter extends React.Component {\n  render() {\n    const _a = this.props,\n          children = _a.children,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(HashRouter, Object.assign({}, props), React.createElement(RouteManagerWithRouter, null, children));\n  }\n\n}\n\nexport { IonReactHashRouter, IonReactRouter };","map":null,"metadata":{},"sourceType":"module"}